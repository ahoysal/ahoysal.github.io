<html>

<head>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <h1>GilgaMesh</h1>
        <div style="text-align: center;">(CS184 Summer 2025 Homework 2 Write-Up)</div><br>
        <div style="text-align: center;">~ Aagrim Hoysal ~</div>
        <div style="text-align: center;">
            <a href="https://ahoysal.github.io/cs184/gilgamesh">Loop Link</a> |
            <a href="https://github.com/cal-cs184/hw2-meshedit-gilgamesh" target="_blank">GitHub Repo</a>
        </div>

        <!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

        <h2>Overview</h2>
        Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole.
        Share your thoughts on what interesting things you've learned from completing the homework.

        <h2>Section I: Bezier Curves and Surfaces</h2>

        <h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
        De Casteljau's algorithm is a way to define a nth-degree bezier curve in terms of a parametric function over \(0
        \leq t \leq 1\). The curve is described as a recursive linear interpolation between points, where interpolating
        between the first and second point with parameter \(t\) provides the first point for the next pass, the
        interpolation of the second and third points provides the second point, etc. This is done until there is only
        one point left, which becomes the point on the curve at \(t\).
        <br><br>
        In effect, we take the point \((1-t)\) of the way along each edge connecting adjacent points, starting from the
        lower indexed point to the higher indexed point. We then connect each of those new points and do the same thing,
        taking the point between successive points \((1-t)\) along the edge, until there are no more edges.
        <br><br>
        To implement de Casteljau's algorithm, I created a function that performed one step of the process; namely, took
        in \(n+1\) points, interpolated along the edges, and returned a list of the \(n\) resulting points. Evaluating
        the full bezier curve was then just a matter of calling the function recursively until only one point remained
        and there were no more edges to interpolate.
        <br><br>
        Below is a table displaying de Casteljau's algorithm for a 5th degree bezier curve with 6 control points at each
        step of interpolation, with the newest edges and points in red. Typically bezier curves for graphics tend to be
        cubic beziers strung together, but the
        same algorithm works for any number of points greater than two. Notice how the number of points and edges
        decreases by one at each step. The final image shows the final curve, which is the parametric function defined
        by de Casteljau's from \(0 \leq t \leq 1\).
        <br><br>

        <div style="display: flex; flex-direction: column; align-items: center;">
            <table style="width: 100%; text-align: center; border-collapse: separate; border-width: 1em;">
                <tr>
                    <td style="text-align: center;">
                        <img src="images/bezier0.png" width="300px" />
                        <figcaption>Step 0, 6 points, 5 edges</figcaption>
                    </td>
                    <td style="text-align: center;">
                        <img src="images/bezier1.png" width="300px" />
                        <figcaption>Step 1, 5 points, 4 edges</figcaption>
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        <img src="images/bezier2.png" width="300px" />
                        <figcaption>Step 2, 4 points, 3 edges</figcaption>
                    </td>
                    <td style="text-align: center;">
                        <img src="images/bezier3.png" width="300px" />
                        <figcaption>Step 3, 3 points, 2 edges</figcaption>
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        <img src="images/bezier4.png" width="300px" />
                        <figcaption>Step 4, 2 points, 1 edge</figcaption>
                    </td>
                    <td style="text-align: center;">
                        <img src="images/bezier5.png" width="300px" />
                        <figcaption>Step 5, 1 point</figcaption>
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        <img src="images/bezier6.png" width="300px" />
                        <figcaption>The final point \(t=0.5\) on the curve</figcaption>
                    </td>
                    <td style="text-align: center;">
                        <img src="images/bezier7.png" width="300px" />
                        <figcaption>The full final curve, \(0 \leq t \leq 1\)</figcaption>
                    </td>
                </tr>
            </table>
        </div>
        <br>
        Additionally, here is an animated version of the last step of a different curve at various t values.
        <br><br>
        <img src="images/bezier.gif" width="50%" class="center" />

        <h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>

        <figure style="float: inline-end;">
            <img src="images/bezTeapot.png" width="300px" />
            <figcaption>Teapot generated from bezier surface.<br>Triangles were generated from<br>sampling the bezier
                surface.</figcaption>
        </figure>

        Bezier surfaces in 3D are defined by \(n \times n\) 3D points, with interpolation over two parameters, \(u\) and
        \(v\), ranging between zero and one. Extending de Casteljau's algorithm to surfaces is simply a matter of
        evaluating the same algorithm as a curve at \(t = u\) on each row. This gives us one point per row, giving a
        total of \(n\) points. We can then feed the \(n\) resulting points into de Casteljau's algorithm for a curve
        again, with \(t = v\), giving us a single point. In total, letting \(0 \leq u, v \leq 1\) defines the parametric
        surface of the bezier surface.

        <br><br>

        Implementing 3D bezier surfaces requires almost no modification from the 2D algorithm except using 3D points to
        interpolate between, running the original algorithm \(n\) times along the rows with \(t = u\), and running the
        original algorithm one more time on the output of the \(n\) rows with \(t = v\).

        <h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

        <h3>Part 3: Area-weighted vertex normals</h3>
        Half-edge meshes allow for efficient calculation of area weighted vertex normals. To calculate them for a
        vertex, one must find all faces the vertex is a part of, find their normal, and weight that normal by the area
        of the face it is a part of. The weighted average of the normal of all surrounding faces should be normal of the
        vertex. Finding this normal allows for lighting calculations to be done per vertex in Gourard shading, which can
        then be interpolated using barycentric coordinates, or interpolating the normals themselves and performing the
        lighting calculations per fragment as in Phong shading.

        <br><br>
        <figure style="float: inline-end;">
            <img src="images/flatPot.png" width="300px">
            <figcaption>Flat shaded teapot.<br>Very clear edges to faces.</figcaption>
            <br>
            <img src="images/phongPot.png" width="300px">
            <figcaption>Phong shaded teapot.<br>Face edges aren't as visible.<br>Corners tend to be lighted weirdly.
            </figcaption>
        </figure>

        I assumed all faces were triangles as per the problem statement, so I had assurances that after three successive
        half-edges I would end up at the original half edge and would have traversed all half-edges of the face. Thus,
        starting at the half-edge stored by the vertex itself that points away from the vertex, I iterated through all
        three half-edges of the triangle and stored their associated source vertexes. Then, I took the cross product the
        vectors pointing from the first point to the second and third respectively, which serves as a normal scaled by
        the face's area*, and added it to an accumulated vector. Finally, I took the third edge's twin and set that as
        the start of the next face to iterate through. This works because the third edge points back to the original
        vertex, so it's twin must originate from that vertex, meaning the twin's face must be a face that surrounds the
        vertex. Using this, we enforce the invariant that the first half-edge we look at per face is the one facing away
        from the original vertex. This allows for an easy check on when to end the process– there is only one half-edge
        per face that points away from a particular vertex, and we maintain that the third edge's twin always points
        away from the original vertex, so if the twin is the same as our starting half-edge then we must have started at
        that face. Once we have the accumulated vector, we can normalize it and use it as a vertex normal.
        <br><br>
        This leaves two questions unanswered: why does the cross product serve as a normal scaled by area*? And what
        about boundaries? The latter is quite simple; if the half-edge is a boundary edge, then we can go to its twin
        (which must not be on the boundary, as well as must point toward the vertex due to the invariant and that
        half-edges point the opposite way of their twin, as well as not being on an edge) and then it's next (which must
        point away from the original vertex) to get to another half-edge not on the boundary that points away from the
        original vertex. Then we can continue the algorithm as normal.
        <br><br>
        The cross product being a normal scaled by area* comes from the fact that the cross product is perpendicular to
        both vectors, and its magnitude is the area of the parallelogram that is made by the two vectors. If we divide
        the magnitude/area by two, we get half the area of the parallelogram, i.e. the area of the triangle. We also
        know the direction is normal to the surface, and because the triangles are always oriented counterclockwise we
        can calculate which direction the normal should go easily. If we accumulate all of the cross products, we will
        get the weighted normals scaled by the area of the triangle times two; however, because we eventually are going
        to normalize the accumulated cross products and the two is a constant factor, we don't have to divide it out
        because the final normalization will do so anyways.


        <h3>Part 4: Edge flip</h3>
        In theory, edge flips are simple. We just need to move a diagonal separating a quadrilateral to the other
        diagonal. With half-edges, we need to shuffle some pointers. How hard could it be? So I thought I could logic it
        out. So despite the <a
            href="https://cs184.eecs.berkeley.edu/su25/hw/hw2/section2/#mesh-pointer-recommendations">warnings</a> I
        decided to try and think through all the pointer reassignments. That went predictably bad, with faces
        disappearing left and right and segfaults galore. After trying to debug it a few times and figuring out there
        were both pointers to itself and pointer loops of length five, I finally heeded the warning and reassigned all
        of the pointers, even if they theoretically shouldn't have changed. Turns out I forgot to assign two of the six
        “next” pointers in my original implementation… Then, I was able to cull the unnecessary pointer reassignments
        using many, many drawings of triangles, checking along the way to make sure flipping still worked.
        <br><br>
        I was spending a lot of time initially trying to make sure I wasn't accessing modified pointers instead of the
        original, so to make my life easier I made copies of the originals at the very top of the function. This helped
        immensely with implementation but also with readability, as the code wasn't a jumble of
        <code>self->next()->next()->vertex()->halfedge()->face() = twin->next()->face()->next()->next()->face();</code>
        (exaggerating of course, but…).
        <br><br>
        <figure>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <table style="width: 100%; text-align: center; border-collapse: separate; border-width: 1em;">
                    <tr>
                        <td style="text-align: center;">
                            <img src="images/normalPot.png" width="300px" />
                            <figcaption>No flipping</figcaption>
                        </td>
                        <td style="text-align: center;">
                            <img src="images/flipedPot.png" width="300px" />
                            <figcaption>Some flipping</figcaption>
                        </td>
                        <td style="text-align: center;">
                            <img src="images/uhPot.png" width="300px" />
                            <figcaption>Too much flipping</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <figcaption>Comparison of the original pot mesh, the pot mesh after some flips, and the pot mesh after
                legal but malicious flips that result in a very different geometry</figcaption>
        </figure>

        <h3>Part 5: Edge split</h3>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
        consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
        pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est
        laborum.

        <h3>Part 6: Loop subdivision for mesh upsampling</h3>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
        consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
        pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est
        laborum.

        <h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
        consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
        pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est
        laborum.

        <h2>Additional Notes (please remove)</h2>
        <ul>
            <li>You can also add code if you'd like as so: <code>code code code</code></li>
            <li>If you'd like to add math equations,
                <ul>
                    <li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
                    <li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
                </ul>
            </li>
        </ul>
    </div>
</body>

<footer>
    Webpage based off <a href="https://github.com/cal-cs184/hw-webpage" target="_blank">CS 184 homework write up
        template</a>
</footer>

</html>